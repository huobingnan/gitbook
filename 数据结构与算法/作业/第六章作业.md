---
title: 第六章作业
date: 2021-12-16
tags:
  - 数据结构与算法
---

| 项目 | 值                      |
| ---- | ----------------------- |
| 姓名 | 霍丙南                  |
| 学号 | 21200340022             |
| 专业 | 人工智能（第二学士学位) |


## 题一

给定关键字序列{105, 50, 30, 25, 85, 40, 100, 12, 10, 28}分别写出直接插入排序，希尔排序，起泡排序，直接选择排序，快速排序每一趟的运行结果。

### 起泡排序

```
1  -> [ 50, 30, 25, 85, 40, 100, 12, 10, 28, 105 ]
2  -> [ 30, 25, 50, 40, 85, 12, 10, 28, 100, 105 ]
3  -> [ 25, 30, 40, 50, 12, 10, 28, 85, 100, 105 ]
4  -> [ 25, 30, 40, 12, 10, 28, 50, 85, 100, 105 ]
5  -> [ 25, 30, 12, 10, 28, 40, 50, 85, 100, 105 ]
6  -> [ 25, 12, 10, 28, 30, 40, 50, 85, 100, 105 ]
7  -> [ 12, 10, 25, 28, 30, 40, 50, 85, 100, 105 ]
8  -> [ 10, 12, 25, 28, 30, 40, 50, 85, 100, 105 ]
9  -> [ 10, 12, 25, 28, 30, 40, 50, 85, 100, 105 ]
10 -> [ 10, 12, 25, 28, 30, 40, 50, 85, 100, 105 ]
```

### 选择排序
```
1  -> [ 10, 105, 50, 30, 85, 40, 100, 25, 12, 28 ]
2  -> [ 10, 12, 105, 50, 85, 40, 100, 30, 25, 28 ]
3  -> [ 10, 12, 25, 105, 85, 50, 100, 40, 30, 28 ]
4  -> [ 10, 12, 25, 28, 105, 85, 100, 50, 40, 30 ]
5  -> [ 10, 12, 25, 28, 30, 105, 100, 85, 50, 40 ]
6  -> [ 10, 12, 25, 28, 30, 40, 105, 100, 85, 50 ]
7  -> [ 10, 12, 25, 28, 30, 40, 50, 105, 100, 85 ]
8  -> [ 10, 12, 25, 28, 30, 40, 50, 85, 105, 100 ]
9  -> [ 10, 12, 25, 28, 30, 40, 50, 85, 100, 105 ]
10 -> [ 10, 12, 25, 28, 30, 40, 50, 85, 100, 105 ]
```

### 插入排序

```
1  -> [ 50, 105, 30, 25, 85, 40, 100, 12, 10, 24 ]
2  -> [ 30, 50, 105, 25, 85, 40, 100, 12, 10, 24 ]
3  -> [ 25, 30, 50, 105, 85, 40, 100, 12, 10, 24 ]
4  -> [ 25, 30, 50, 85, 105, 40, 100, 12, 10, 24 ]
5  -> [ 25, 30, 40, 50, 85, 105, 100, 12, 10, 24 ]
6  -> [ 25, 30, 40, 50, 85, 100, 105, 12, 10, 24 ]
7  -> [ 12, 25, 30, 40, 50, 85, 100, 105, 10, 24 ]
8  -> [ 10, 12, 25, 30, 40, 50, 85, 100, 105, 24 ]
9  -> [ 10, 12, 24, 25, 30, 40, 50, 85, 100, 105 ]
10 -> [ 10, 12, 24, 25, 30, 40, 50, 85, 100, 105 ]
```

## 题二

试在单链表上实现直接插入排序。

```c++
/**
 * 单链表的定义
 *  第一个节点为头节点，存储链表的长度信息和链表头指针信息
 *   |head| --> |data| --> |data| --> nullptr
 */
typedef struct ListNode {
    ListNode *next;
    int data;
}ListNode;

// 对单链表进行冒泡排序
void BubbleSort(ListNode *head) {
    for (int i = 0; i < head->data; ++i) {
        ListNode *first = head->next;
        int count = head->data - i;
        for (int j = 0; j < count; ++j) {
            if (first->data > first->next->data) {
                // swap
                // 这里只进行数据域的交换，节点并不参与交换
                int temp = first->data;
                first->data = first->next->data;
                first->next->data = temp;
            }
            first = first->next;
        }
    }
}
```

## 题三

设计算法实现如下功能：不用完整排序，找出按递增序关系为第K位的元素。

```c++
/**
 * 查找序列中递增关系第K位的元素
 * @param array 查找的序列 
 * @param len   序列的长度
 * @param k     序列中递增关系第K位
 * @return int  序列中递增关系第K位的元素
 */
int KthNumber(int *array, int len, int k) {
    if (k <= 0 || len < 0){
        return -1;
    } 
    // 这里采用选择排序的方式进行
    for (int i = 0; i < k; ++i) {
        for (int j = i + 1; j < len; ++j) {
            if (array[j] < array[i]) {
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
    }
    return array[k - 1];
}
```

## 题四

已知散列函数 H(K) = k mod 13， 关键字序列为{25, 37, 52, 43, 84, 99, 120, 15, 26, 11, 70, 82}，试分别画出采用线性探测法和拉链法处理冲突时的散列表，并计算查找成功的平均查找长度。设散列表长度为13。

![[哈希碰撞的解决方法.png]]

## 题五

试写一个判别给定二叉树是否为二叉排序树的算法，设此二叉树以二叉链表作为存储结构。

```c++
typedef struct BiNode {
    int Data;
    BiNode *Left;
    BiNode *Right;
}BiNode;

#define BiTree BiNode*
#define Left(N) (N->Left)
#define Right(N) (N->Right)
#define Data(N) (N->Data)

void FlatBinarySearchTree(BiTree tree, std::vector<int> *res) {
    if (tree == nullptr) {
        return;
    }
    FlatBinarySearchTree(Left(tree), res);
    res->push_back(tree->Data);
    FlatBinarySearchTree(Right(tree), res);
}

// 判定是否为二叉搜索树
// 1. 得到二叉树的中序遍历序列
// 2. 判断此序列是否为递增序列
// 3. 若是递增序列，则是二叉排序树，否则不是二叉排序树
bool IsBinarySearchTree(BiTree tree) {
    std::vector<int> collector;
    FlatBinarySearchTree(tree, &collector);
    for (int i = 0, end = collector.size() - 1; i < end; ++i) {
        if (collector[i + 1] < collector[i]) {
            return false;
        }
    }
    return true;
}
```
