---
title: Java volatile关键字作用
date: 2021-09-02
tags:
    - "Java"
    - "JVM"
---

## 概述

volatile是java中的一个关键字，用于修饰变量。被此关键修饰的变量可以禁止对此变量操作的指令进行重排，还有保持内存的可见性。
简言之它的作用就是：

1. 禁止指令重排

2. 保持内存的可见性

## 禁止指令重排

CPU在执行代码时，为了提高执行效率，有时会将代码乱序执行。但是乱序也不是随随便便的乱序，而是在一定规则下，对指令进行重排然后执行。指令重排在单线程下没有什么问题，但是在多线程环境下容易造成并发安全问题。

## 保持内存的可见性

何谓之内存的可见性，其实笔者在[Java线程安全问题](https://www.cnblogs.com/Huobn/p/14514332.html)一文中对此问题进行过阐述。线程是一种资源，线程在执行代码时有自己的工作内存（线程执行的堆栈）。一般来说，一些共享变量存在于**堆内存**中，线程对于共享变量的操作实际上对自己工作内存中**共享变量的副本**进行操作，线程并不会直接操作堆内存的中的共享变量。

![JMM](https://cdn.jsdelivr.net/gh/huobingnan/my_image_hosting@master/JMM.12sj47r5qvfk.png)

这里我们可以通过字节码进行验证，首先我们的java源代码是对变量`a`进行一个自增操作 => `a++`，而其对应的字节码为：

```
getstatic #2 
iconst_1
iadd
putstatic #2
return
```

从字节码层面可以体现出工作内存与主存。但是，Java内存可见性的控制并不是在字节码层面，而是在JVM层面。即使你对变量`a`使用`volatile`修饰，那么编译之后的字节码也没有变化。

JVM定义了对于内存的8种操作：

![JVM8种内存操作](https://cdn.jsdelivr.net/gh/huobingnan/my_image_hosting@master/JVM8种内存操作.midhrakt0gg.png)

这些操作是JVM层面的操作，在Java源代码中并不能感受到。线程在所操作的共享变量，其实是存在于自己线程栈中的变量副本。在多线程并发的情况下，如果有其他线程修改了主存中的值，那么其他线程无法感知这种修改。因为线程在通过READ-LOAD操作拷贝完副本之后，之后线程对于数据的操作都是对于副本进行的。这也就是内存可见性的问题的来源，简言之就是线程之间无法感知对于主存共享变量的修改。

`volatile`关键字就是解决了这样的问题，使得线程对于主存具有一定的可见性。其解决方案是对于volatile标注的变量，每次在使用之前都要重新从主存中加载，同时每次对于变量完成修改后，要及时的将变量写回主存。

![JVM内存操作](https://cdn.jsdelivr.net/gh/huobingnan/my_image_hosting@master/JVM内存操作.6pyc72z8a2w0.png)

通过这样的操作，每个线程就能感知到内存中变量的变化，并及时更新自己副本的值。不过需要注意的是，volatile关键字并不能保障并发的安全性。尽管每次在使用之前都会更新值，但是这并没有解决变量访问的有序性。所以在高并发场景下依然会出现问题。